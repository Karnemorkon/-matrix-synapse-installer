#!/bin/bash
# ===================================================================================
# Backup Module - Automated backup functionality
# ===================================================================================

# --- Constants ---
readonly BACKUP_BASE_DIR="/DATA/matrix-backups"

# --- Functions ---
setup_backup_system() {
    if [[ "${CONFIG[SETUP_BACKUP]}" != "true" ]]; then
        return 0
    fi
    
    log_info "Налаштування системи резервного копіювання"
    
    # Create backup directory
    mkdir -p "${BACKUP_BASE_DIR}"
    
    # Create backup script
    create_backup_script
    
    # Setup cron job if not manual
    if [[ "${CONFIG[BACKUP_SCHEDULE]}" != "manual" ]]; then
        setup_backup_cron
    fi
    
    log_success "Систему резервного копіювання налаштовано"
}

create_backup_script() {
    local backup_script="${BACKUP_BASE_DIR}/backup-matrix.sh"
    
    log_info "Створення скрипта резервного копіювання"
    
    cat > "${backup_script}" << EOF
#!/bin/bash
# Matrix Synapse Backup Script
# Generated by Matrix Synapse Installer

set -euo pipefail

# Configuration
BACKUP_DIR="${BACKUP_BASE_DIR}"
MATRIX_DIR="${CONFIG[BASE_DIR]}"
DATE=\$(date +%Y-%m-%d_%H-%M-%S)
BACKUP_NAME="matrix-backup-\$DATE"
BACKUP_PATH="\$BACKUP_DIR/\$BACKUP_NAME"
LOG_FILE="\$BACKUP_DIR/backup.log"

# Logging function
log_message() {
    echo "\$(date '+%Y-%m-%d %H:%M:%S') - \$1" | tee -a "\$LOG_FILE"
}

# Main backup function
main() {
    log_message "=== Початок резервного копіювання Matrix ==="
    
    # Create backup directory
    mkdir -p "\$BACKUP_PATH"
    
    # Stop services for consistent backup
    log_message "Зупинка сервісів для консистентного бекапу"
    cd "\$MATRIX_DIR"
    docker compose stop
    
    # Backup configuration files
    log_message "Резервне копіювання конфігураційних файлів"
    cp -r "\$MATRIX_DIR/synapse/config" "\$BACKUP_PATH/" 2>/dev/null || true
    cp -r "\$MATRIX_DIR/synapse/data" "\$BACKUP_PATH/" 2>/dev/null || true
    
    # Backup bridge configurations
$(generate_bridge_backup_commands)
    
    # Backup Docker Compose files
    log_message "Резервне копіювання Docker Compose файлів"
    cp "\$MATRIX_DIR/docker-compose.yml" "\$BACKUP_PATH/" 2>/dev/null || true
    cp "\$MATRIX_DIR/.env" "\$BACKUP_PATH/" 2>/dev/null || true
    
    # Start PostgreSQL for database backup
    log_message "Запуск PostgreSQL для бекапу бази даних"
    docker compose start postgres
    sleep 10
    
    # Backup database
    log_message "Резервне копіювання бази даних"
    docker compose exec -T postgres pg_dump -U matrix_user matrix_db > "\$BACKUP_PATH/database.sql"
    
    # Restart all services
    log_message "Перезапуск всіх сервісів"
    docker compose up -d
    
    # Create archive
    log_message "Створення архіву"
    cd "\$BACKUP_DIR"
    tar -czf "\$BACKUP_NAME.tar.gz" "\$BACKUP_NAME"
    rm -rf "\$BACKUP_NAME"
    
    # Cleanup old backups (keep last 7)
    log_message "Очищення старих бекапів"
    find "\$BACKUP_DIR" -name "matrix-backup-*.tar.gz" -type f -mtime +7 -delete
    
    # Calculate backup size
    BACKUP_SIZE=\$(du -h "\$BACKUP_DIR/\$BACKUP_NAME.tar.gz" | cut -f1)
    
    log_message "=== Резервне копіювання завершено: \$BACKUP_NAME.tar.gz (розмір: \$BACKUP_SIZE) ==="
}

# Error handling
trap 'log_message "❌ Помилка під час резервного копіювання"; cd "\$MATRIX_DIR"; docker compose up -d; exit 1' ERR

# Run main function
main "\$@"
EOF
    
    chmod +x "${backup_script}"
    
    # Create backup script in bin directory for easy access
    local bin_backup="${CONFIG[BASE_DIR]}/bin/backup.sh"
    cat > "${bin_backup}" << EOF
#!/bin/bash
# Matrix Backup Wrapper Script
exec "${backup_script}" "\$@"
EOF
    chmod +x "${bin_backup}"
    
    log_success "Скрипт резервного копіювання створено"
}

generate_bridge_backup_commands() {
    if [[ "${CONFIG[INSTALL_BRIDGES]}" != "true" ]]; then
        return 0
    fi
    
    local commands=""
    
    [[ "${CONFIG[INSTALL_SIGNAL_BRIDGE]}" == "true" ]] && commands+="    cp -r \"\$MATRIX_DIR/signal-bridge\" \"\$BACKUP_PATH/\" 2>/dev/null || true\n"
    [[ "${CONFIG[INSTALL_WHATSAPP_BRIDGE]}" == "true" ]] && commands+="    cp -r \"\$MATRIX_DIR/whatsapp-bridge\" \"\$BACKUP_PATH/\" 2>/dev/null || true\n"
    [[ "${CONFIG[INSTALL_TELEGRAM_BRIDGE]}" == "true" ]] && commands+="    cp -r \"\$MATRIX_DIR/telegram-bridge\" \"\$BACKUP_PATH/\" 2>/dev/null || true\n"
    [[ "${CONFIG[INSTALL_DISCORD_BRIDGE]}" == "true" ]] && commands+="    cp -r \"\$MATRIX_DIR/discord-bridge\" \"\$BACKUP_PATH/\" 2>/dev/null || true\n"
    
    if [[ -n "${commands}" ]]; then
        echo -e "    log_message \"Резервне копіювання конфігурацій мостів\"\n${commands}"
    fi
}

setup_backup_cron() {
    local backup_script="${BACKUP_BASE_DIR}/backup-matrix.sh"
    local cron_schedule
    
    case "${CONFIG[BACKUP_SCHEDULE]}" in
        daily)
            cron_schedule="0 2 * * *"
            ;;
        weekly)
            cron_schedule="0 2 * * 0"
            ;;
        *)
            log_warn "Невідомий розклад бекапу: ${CONFIG[BACKUP_SCHEDULE]}"
            return 1
            ;;
    esac
    
    log_info "Налаштування cron для автоматичного бекапу (${CONFIG[BACKUP_SCHEDULE]})"
    
    # Add cron job
    (crontab -l 2>/dev/null; echo "${cron_schedule} ${backup_script}") | crontab -
    
    log_success "Cron job для бекапу налаштовано"
}

create_restore_script() {
    local restore_script="${BACKUP_BASE_DIR}/restore-matrix.sh"
    
    log_info "Створення скрипта відновлення"
    
    cat > "${restore_script}" << EOF
#!/bin/bash
# Matrix Synapse Restore Script
# Generated by Matrix Synapse Installer

set -euo pipefail

# Configuration
BACKUP_DIR="${BACKUP_BASE_DIR}"
MATRIX_DIR="${CONFIG[BASE_DIR]}"
LOG_FILE="\$BACKUP_DIR/restore.log"

# Logging function
log_message() {
    echo "\$(date '+%Y-%m-%d %H:%M:%S') - \$1" | tee -a "\$LOG_FILE"
}

# Usage function
usage() {
    echo "Використання: \$0 <backup-file.tar.gz>"
    echo "Приклад: \$0 matrix-backup-2024-01-01_12-00-00.tar.gz"
    exit 1
}

# Main restore function
main() {
    local backup_file="\$1"
    
    if [[ ! -f "\$backup_file" ]]; then
        echo "❌ Файл бекапу не знайдено: \$backup_file"
        usage
    fi
    
    log_message "=== Початок відновлення Matrix з \$backup_file ==="
    
    # Stop all services
    log_message "Зупинка всіх сервісів"
    cd "\$MATRIX_DIR"
    docker compose down
    
    # Extract backup
    local temp_dir="\$(mktemp -d)"
    log_message "Розпакування бекапу до \$temp_dir"
    tar -xzf "\$backup_file" -C "\$temp_dir"
    
    local backup_name=\$(basename "\$backup_file" .tar.gz)
    local backup_path="\$temp_dir/\$backup_name"
    
    # Restore configuration files
    log_message "Відновлення конфігураційних файлів"
    if [[ -d "\$backup_path/config" ]]; then
        cp -r "\$backup_path/config" "\$MATRIX_DIR/synapse/"
    fi
    
    if [[ -d "\$backup_path/data" ]]; then
        cp -r "\$backup_path/data" "\$MATRIX_DIR/synapse/"
    fi
    
    # Restore bridge configurations
$(generate_bridge_restore_commands)
    
    # Restore Docker Compose files
    log_message "Відновлення Docker Compose файлів"
    [[ -f "\$backup_path/docker-compose.yml" ]] && cp "\$backup_path/docker-compose.yml" "\$MATRIX_DIR/"
    [[ -f "\$backup_path/.env" ]] && cp "\$backup_path/.env" "\$MATRIX_DIR/"
    
    # Start PostgreSQL
    log_message "Запуск PostgreSQL"
    docker compose up -d postgres
    sleep 15
    
    # Restore database
    if [[ -f "\$backup_path/database.sql" ]]; then
        log_message "Відновлення бази даних"
        docker compose exec -T postgres psql -U matrix_user -d matrix_db < "\$backup_path/database.sql"
    fi
    
    # Start all services
    log_message "Запуск всіх сервісів"
    docker compose up -d
    
    # Cleanup
    rm -rf "\$temp_dir"
    
    log_message "=== Відновлення завершено успішно ==="
}

# Check arguments
if [[ \$# -ne 1 ]]; then
    usage
fi

# Error handling
trap 'log_message "❌ Помилка під час відновлення"; exit 1' ERR

# Run main function
main "\$@"
EOF
    
    chmod +x "${restore_script}"
    
    log_success "Скрипт відновлення створено"
}

generate_bridge_restore_commands() {
    if [[ "${CONFIG[INSTALL_BRIDGES]}" != "true" ]]; then
        return 0
    fi
    
    local commands=""
    
    [[ "${CONFIG[INSTALL_SIGNAL_BRIDGE]}" == "true" ]] && commands+="    [[ -d \"\$backup_path/signal-bridge\" ]] && cp -r \"\$backup_path/signal-bridge\" \"\$MATRIX_DIR/\"\n"
    [[ "${CONFIG[INSTALL_WHATSAPP_BRIDGE]}" == "true" ]] && commands+="    [[ -d \"\$backup_path/whatsapp-bridge\" ]] && cp -r \"\$backup_path/whatsapp-bridge\" \"\$MATRIX_DIR/\"\n"
    [[ "${CONFIG[INSTALL_TELEGRAM_BRIDGE]}" == "true" ]] && commands+="    [[ -d \"\$backup_path/telegram-bridge\" ]] && cp -r \"\$backup_path/telegram-bridge\" \"\$MATRIX_DIR/\"\n"
    [[ "${CONFIG[INSTALL_DISCORD_BRIDGE]}" == "true" ]] && commands+="    [[ -d \"\$backup_path/discord-bridge\" ]] && cp -r \"\$backup_path/discord-bridge\" \"\$MATRIX_DIR/\"\n"
    
    if [[ -n "${commands}" ]]; then
        echo -e "    log_message \"Відновлення конфігурацій мостів\"\n${commands}"
    fi
}
